const std = @import("std");
const Allocator = std.mem.Allocator;
const migraine = @import("migraine.zig");

///
/// migraine --help
///
const MIGRAINE_HEADER = "Migraine 0.0.1a\n";

const InterpreterOptions = struct {
    var help: bool = false;
    var file: ?[]const u8 = null;
    var eval: ?[]const u8 = null;
    var verbose: bool = false;
    var size: ?i32 = null;
    var dyna: bool = false;
    var input: ?[]const u8 = null;
    var inputDec: ?[]const u8 = null;
    var alwaysFlush: bool = true;
    var buffered: bool = false;
};

fn help(writer: anytype) !void {
    try writer.print("\n", .{});
    try header(writer);
    const commands =
        \\
        \\ Example:
        \\      migraine <file_name.bf> [options]
        \\
        \\Global Options:
        \\      --help          Print this help. (Not Implemented)
        \\      --file          The brainfuck source-code file path (Not Implemented)
        \\      --eval          String is interpreted as a brainfuck program (Not Implemented)
        \\      --verbose       Prints the loaded program and the output as sections. (Not Implemented)
        \\
        \\Memory Related Options:
        \\      --size          The memory size in KBytes. The default size is the same as the original 
        \\                      brainfuck interpreter (30KB) (Not Implemented)
        \\      --dyna          Instantiate memory dynamically without any fixed length. (Not Implemented)
        \\
        \\Input Related Options:
        \\      --input         Non interactive mode. Pass all the input needed 
        \\                      to run the program. If not passed, a input prompt will
        \\                      appear to collect one Byte at a time, when the program
        \\                      requests a read ','.  (Not Implemented)
        \\      --input-int     Non interactive mode. Pass inputs as comma separated  
        \\                      integers from 0 to 255(0-255) and convert each integer as Byte. (Not Implemented)
        \\
        \\Output Related Options:
        \\      --always-flush  Flush as output is generated by a brainfuck program  (Not Implemented)
        \\      --buffered      Enable buffered output, flushing output only at the end of the program`s execution. (Not Implemented)
        \\
    ;
    try writer.print("{s}\n", .{commands});
}

fn header(writer: anytype) !void {
    try writer.print("{s}\n", .{MIGRAINE_HEADER});
}

fn processArguments(allocator: Allocator) !InterpreterOptions {}

pub fn main() !void {
    const err = std.io.getStdErr().writer();
    const out = std.io.getStdOut().writer();
    const in = std.io.getStdIn().reader();
    try help(out);
    //try header(out);

    var arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);
    const allocator = arena.allocator();
    defer arena.deinit();

    //to compile to windows its mandatory to use 'argsWithAllocator'
    var args = try std.process.argsWithAllocator(allocator);
    _ = args.skip();

    if (args.next()) |path_arg| {
        const loaded = try migraine.loadProgram(allocator, path_arg);
        var diagnostics = migraine.InterpreterDiagnostics{ .detailed_message = undefined, .failed_opcode = undefined };
        const interpreter = try migraine.Interpreter.init(allocator);
        interpreter.eval(loaded, in, out, &diagnostics) catch |er| {
            try err.print("{}:\n\t{s} {d}\n", .{ er, diagnostics.detailed_message, diagnostics.failed_opcode });
            return;
        };
    } else {
        try err.print("No source file found!\nUsage: \n\tmigraine <program.bf>\n", .{});
        return;
    }
}
